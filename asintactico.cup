 
   
/* ---------------Seccion de declaraciones preliminares--------------------*/
package serum;

/* Import the class java_cup.runtime.*  */
import java_cup.runtime.*;
import java.io.FileReader;
   
/* Codigo del parser, se copia integramente a la clase final.
    Agregamos el manejo de errores. */
parser code {:
    
    /* Reporte de error encontrado. */
    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {                
                m.append(" in line "+(s.left+1));
                if (s.right >= 0)
                    m.append(", column "+(s.right+1));
            }
        }
        m.append(" : "+message);
        System.err.println(m);
    }
   
    /* Cuando se encuentra un error de donde el sistema no puede
        recuperarse, se lanza un error fatal. Se despliega el mensaje
        de error y se finaliza la ejecucion. */
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }

    /* Metodo main para garantizar la ejecucion del analizador
       lexico y sintactico, ademas que se pase como parametro la tabla
       de simbolos correspondiente. */
    public static void main(String[] args){
        try {
            AnalizadorSintactico asin = new AnalizadorSintactico(
                    new AnalizadorLexico( new FileReader(args[0])));
            Object result = asin.parse().value;
            System.out.println("\n*** Resultados finales ***");
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }
:};
   

   
/* ------------Declaracion de simbolos terminales y no terminales---------- */
   
/* Terminales (tokens obtenidos por el analizador lexico).  

   Terminales que no tienen un valor son listados primero, los terminales que
   tienen un valor como los enteros son listados en la segunda o demas lineas. */
terminal           T_INT, T_BOOL, T_ARRAY;
terminal           IF, ELSE, WHILE;
terminal String    IDENTIFIER;
terminal String    INTEGER_LITERAL, BOOL_LITERAL;
//terminal String    STRING_LITERAL;
terminal           ASSIGN_OP;
terminal           EQ_OP, LT_OP, GT_OP, LET_OP, GET_OP, SUM_OP, SUBS_OP, PROD_OP, DIV_OP, AND_OP, OR_OP, NOT_OP;
terminal           LPAREN, RPAREN, LBRACKET, RBRACKET;
terminal           START_BLOCK, END_BLOCK, SEPARATOR;
   
/* No terminales usados en la seccion gramatical. 

   Primero se lista los no terminales que tienen un valor Object y despues
   se lista los no terminales que tienen un entero. Un Object se refiere a que
   no tienen tipo, pudiendo ser entero o String. */
non terminal InstructionList statements;
non terminal Instruction statement, then_statement, non_if_statement; // Top level structure
non terminal Instruction declaration, assignment;                                 // Variable manip statements
non terminal Type        type; 
non terminal Expression  expression; 
non terminal Variable    variable;                             

/* -------------Seccion de predencia y asociacion de los terminales----------- */
  
  /* Integer operators */
  precedence left SUM_OP, SUBS_OP;
  precedence left PROD_OP, DIV_OP;

  /* Boolean operators */
  precedence left EQ_OP, LT_OP, GT_OP, LET_OP, GET_OP;
  precedence left OR_OP;
  precedence left AND_OP;

  // Should we add precedence for (L/R)PARENS and NOT_OP?
  // UMINOS_OP missing!


/* ------------------- Seccion de la gramatica ------------------------ */

start with statements;

/* Top level statements */
statements ::= statement:s
                {:
                    System.out.println("statements ::= statement");
                    RESULT = new InstructionList(s);
                :}
             | statement:s SEPARATOR
                {:
                    System.out.println("statements ::= statement SEPARATOR");
                    RESULT = new InstructionList(s);
                :}
             | SEPARATOR // Empty statement
                {:
                    System.out.println("statements ::= SEPARATOR");
                    RESULT = new InstructionList();
                :}
             | statement:s SEPARATOR statements:ss 
                {:
                    System.out.println("statements ::= statement SEPARATOR statements");
                    RESULT = new InstructionList(s, ss);
                :}
             ;

statement  ::= IF expression:e SEPARATOR statement:s
                {:
                    System.out.println("statement ::= IF expression SEPARATOR statement");
                    RESULT = new IfSentence(e, s);
                :}
             | IF expression:e statement:s
                {:
                    System.out.println("statement ::= IF expression statement");
                    RESULT = new IfSentence(e, s);
                :}
             | IF expression:e SEPARATOR then_statement:then ELSE SEPARATOR statement:els 
                {:
                    System.out.println("statement ::= IF expression SEPARATOR then_statement ELSE SEPARATOR statement");
                    RESULT = new IfElseSentence(e, then, els);
                :}
             | IF expression:e then_statement:then ELSE SEPARATOR statement:els 
                {:
                    System.out.println("statement ::= IF expression then_statement ELSE SEPARATOR statement");
                    RESULT = new IfElseSentence(e, then, els);
                :}
             | IF expression:e SEPARATOR then_statement:then ELSE statement:els 
                {:
                    System.out.println("statement ::= IF expression SEPARATOR then_statement ELSE statement");
                    RESULT = new IfElseSentence(e, then, els);
                :}
             | IF expression:e then_statement:then ELSE statement:els 
                {:
                    System.out.println("statement ::= IF expression then_statement ELSE statement");
                    RESULT = new IfElseSentence(e, then, els);
                :}
             | WHILE expression:e SEPARATOR statement:s
                {:
                    System.out.println("statement ::= WHILE expression SEPARATOR statement");
                    RESULT = new WhileSentence(e, s);
                :}
             | WHILE expression:e statement:s
                {:
                    System.out.println("statement ::= WHILE expression statement");
                    RESULT = new WhileSentence(e, s);
                :}
             | non_if_statement:s
                {:
                    System.out.println("statement ::= non_if_statement");
                    RESULT = s;
                :}
             ;

then_statement ::= IF expression:e SEPARATOR then_statement:then ELSE SEPARATOR then_statement:els 
                      {:
                          System.out.println("then_statement ::= IF expression SEPARATOR then_statement ELSE SEPARATOR then_statement");
                          RESULT = new IfElseSentence(e, then, els);
                      :}
                   | IF expression:e then_statement:then ELSE SEPARATOR then_statement:els 
                      {:
                          System.out.println("then_statement ::= IF expression then_statement ELSE SEPARATOR then_statement");
                          RESULT = new IfElseSentence(e, then, els);
                      :}
                   | IF expression:e SEPARATOR then_statement:then ELSE then_statement:els 
                      {:
                          System.out.println("then_statement ::= IF expression SEPARATOR then_statement ELSE then_statement");
                          RESULT = new IfElseSentence(e, then, els);
                      :}
                   | IF expression:e then_statement:then ELSE then_statement:els 
                      {:
                          System.out.println("then_statement ::= IF expression then_statement ELSE then_statement");
                          RESULT = new IfElseSentence(e, then, els);
                      :}
                   | WHILE expression:e SEPARATOR then_statement:s
                      {:
                          System.out.println("then_statement ::= WHILE expression SEPARATOR then_statement");
                          RESULT = new WhileSentence(e, s);
                      :}
                   | WHILE expression:e then_statement:s
                      {:
                          System.out.println("then_statement ::= WHILE expression then_statement");
                          RESULT = new WhileSentence(e, s);
                      :}
                   | non_if_statement:s
                      {:
                          System.out.println("then_statement ::= non_if_statement");
                          RESULT = s;
                      :}
                   ;

non_if_statement ::= START_BLOCK statements:s END_BLOCK
                      {:
                          System.out.println("non_if_statement ::= START_BLOCK statements END_BLOCK");
                          RESULT = s;
                      :}
                   | declaration:d
                      {:
                          System.out.println("non_if_statement ::= declaration");
                          RESULT = d;
                      :}
                   | assignment:a
                      {:
                          System.out.println("non_if_statement ::= assignment");
                          RESULT = a;
                      :}
                   ;

// The statement vs then_statement is for disambiguation purposes
// Solution taken from http://goldparser.org/doc/grammars/example-if-then-else.htm

/* Variable manipulation statements */
declaration ::= type:t IDENTIFIER:id 
                 {:
                    System.out.println("declaration ::= type IDENTIFIER");
                    RESULT = new Declaration(t, id);
                 :}
              | type:t IDENTIFIER:id ASSIGN_OP expression:rhs 
                 {:
                    System.out.println("declaration ::= type IDENTIFIER ASSIGN_OP expression");
                    RESULT = new Initialization(t, id, rhs);
                 :}
              ;

assignment  ::= variable:lhs ASSIGN_OP expression:rhs
                 {:
                    System.out.println("assignment ::= variable ASSIGN_OP expression");
                    RESULT = new Assignment(lhs, rhs);
                 :}
              ;

/* Variable manipulation auxiliar sintactic elements */
type       ::= T_INT 
                 {:
                    System.out.println("type ::= T_INT");
                    RESULT = Type.TInt;
                 :}
             | T_BOOL 
                 {:
                    System.out.println("type ::= T_BOOL");
                    RESULT = Type.TBool;
                 :}
             | type:t T_ARRAY 
                 {:
                    System.out.println("type ::= type T_ARRAY");
                    RESULT = t.reference();
                 :}
             ;

variable   ::= IDENTIFIER:id 
                 {:
                    System.out.println("variable ::= IDENTIFIER");
                    RESULT = new Variable(id);
                 :}
             | variable:id LBRACKET expression:idx RBRACKET
                 {:
                    System.out.println("variable ::= variable LBRACKET expression RBRACKET");
                    RESULT = new ArrayAccess(id, idx);
                 :}
             ;

/* Integer or bool expressions */
expression ::= variable:v 
                 {:
                    System.out.println("expression ::= variable");
                    RESULT = v;
                 :}
             | LPAREN expression:e RPAREN
                 {:
                    System.out.println("expression ::= LPAREN variable RPAREN");
                    RESULT = e;
                 :}

          // Int expressions
             |  INTEGER_LITERAL:c 
                 {:
                    System.out.println("expression ::= INTEGER_LITERAL");
                    RESULT = new Constant(new Integer(c));
                 :}
             | expression:op1 SUM_OP expression:op2 
                 {:
                    System.out.println("expression ::= expression SUM_OP expression");
                    RESULT = new BinaryOp(op1, op2, BinaryOp.OpType.SUM_OP);
                 :}
             | expression:op1 SUBS_OP expression:op2 
                 {:
                    System.out.println("expression ::= expression SUBS_OP expression");
                    RESULT = new BinaryOp(op1, op2, BinaryOp.OpType.SUBS_OP);
                 :}
             | expression:op1 PROD_OP expression:op2 
                 {:
                    System.out.println("expression ::= expression PROD_OP expression");
                    RESULT = new BinaryOp(op1, op2, BinaryOp.OpType.PROD_OP);
                 :}
             | expression:op1 DIV_OP expression:op2 
                 {:
                    System.out.println("expression ::= expression DIV_OP expression");
                    RESULT = new BinaryOp(op1, op2, BinaryOp.OpType.DIV_OP);
                 :}
           
           // Bool expressions
             | BOOL_LITERAL:c
                 {:
                    System.out.println("expression ::= BOOL_LITERAL");
                    RESULT = new Constant(new Boolean(c));
                 :}
             | expression:op1 OR_OP expression:op2 
                 {:
                    System.out.println("expression ::= expression OR_OP expression");
                    RESULT = new BinaryOp(op1, op2, BinaryOp.OpType.OR_OP);
                 :}
             | expression:op1 AND_OP expression:op2 
                 {:
                    System.out.println("expression ::= expression AND_OP expression");
                    RESULT = new BinaryOp(op1, op2, BinaryOp.OpType.AND_OP);
                 :}
             | NOT_OP expression:op1 
                 {:
                    System.out.println("expression ::= NOT_OP expression");
                    RESULT = new UnaryOp(op1, UnaryOp.OpType.NOT_OP);
                 :}
             | expression:op1 EQ_OP expression:op2 
                 {:
                    System.out.println("expression ::= expression EQ_OP expression");
                    RESULT = new BinaryOp(op1, op2, BinaryOp.OpType.EQ_OP);
                 :}
             | expression:op1 LT_OP expression:op2 
                 {:
                    System.out.println("expression ::= expression LT_OP expression");
                    RESULT = new BinaryOp(op1, op2, BinaryOp.OpType.LT_OP);
                 :}
             | expression:op1 GT_OP expression:op2 
                 {:
                    System.out.println("expression ::= expression GT_OP expression");
                    RESULT = new BinaryOp(op1, op2, BinaryOp.OpType.GT_OP);
                 :}
             | expression:op1 LET_OP expression:op2 
                 {:
                    System.out.println("expression ::= expression LET_OP expression");
                    RESULT = new BinaryOp(op1, op2, BinaryOp.OpType.LET_OP);
                 :}
             | expression:op1 GET_OP expression:op2 
                 {:
                    System.out.println("expression ::= expression GET_OP expression");
                    RESULT = new BinaryOp(op1, op2, BinaryOp.OpType.GET_OP);
                 :}
             ;